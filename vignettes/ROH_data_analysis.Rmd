---
title: "Runs of Homozygosity Analysis"
author:
  - name: Najla Abassi
    email: abassi.nejla96@gmail.com
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: lumen
vignette: >
  %\VignetteIndexEntry{ROH_data_analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignettePackage{ROHStats}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,
  warning = FALSE,
  fig.path = "figure/")
```

# Introduction

ROH are uninterrupted homozygous regions of the genome. They appear when two copies of an ancestral haplotype are joined in an individual. Short ROH indicate distant inbreeding, while long ROH indicate recent inbreeding. This guide aims to facilitate the estimate overall homozygosity of a population using data generated by PLINK.

Let's start by loading all the necessary libraries:

```{r load-lib}
library("xlsx")
library("tidyverse")
library("biomaRt")
```

# Data preprocessing and Quality Control

The original data was downloaded from ... in .ped and .map format. We did convert it to .bed .bim .fam format. If your data is in .ped .map format, you should first convert it to be able to follow/replicate this guide. The first step we did is to perform QC using the following metrics:

-   remove heterosomes
-   SNPs with \> 10% missing genotypes
-   SNPs with MAF \< 5%
-   SNPs that are not in HW equilibrium

For that we used the following command in PLINK:

```{bash}
plink --bfile sheep_data --not-chr 23 24 25 26 --geno 0.1 --maf 0.05 --hwe 0.0001 --make-bed --out sheep_data_QC
```

# ROH identification

Now that the data is ready, we can proceed with characterizing ROH in the processed dataset. We start by generating test for hwe. After that, we load the corresponding .hwe file along with the .bim file.

```{r}
hardy_path <- "../inst/plink_output/other_plink_outputs/hardy_filter.hwe" 
bim_path <- "../inst/data/sheep_data_QC.bim"
ni <- 100 # number of individuals as example

y <- homozyg_snp(hardy_path, ni)
x <- homozyg_density(bim_path)
round(y,0)
round(x,0)
```

Now we can extract ROH with the following command:

```{bash}
plink --bfile sheep_data_QC --homozyg-window-snp 50 --homozyg-window-het 1 --homozyg-window-missing 2 --homozyg-gap 100 --homozyg-kb 500 --homozyg-density x --homozyg-snp y --out homozyg_filter
```

where `x` is the minimum number of SNPs to have less than 5% of ROH generated by chance, and `y` is the SNP density. In our example we will just execute the following command:

```{bash}
plink --bfile sheep_data_QC --homozyg-window-snp 50 --homozyg-window-het 1 --homozyg-window-missing 2 --homozyg-gap 100 --homozyg-kb 500 --homozyg-density 55 --homozyg-snp 29 --out homozyg_filter
```

# Statistical analysis

Now let's take a closer look of the ROH distribution in our population:

## Number of ROH and Total run length

```{r nb_length_roh}
indiv_path <- "../inst/plink_output/homozyg_output/homozyg_filter.hom.indiv"

roh_summary_table <- roh_stat(indiv_path)
roh_summary_table

```

Here we can get descriptive statistics for the *number* and *total length* of the identified ROH.

## FROH

FROH is a multipoint approach measuring individual homozygosity and indicates the proportion of the genome included in the ROH per individual. It was calculated according to the formula:

$$ FROH_j = \frac{\sum_{k} \text{length(ROH}_k\text{)}}{L} $$

```{r froh}
FROH_stat <- F_roh(indiv_path,bim_path)
FROH_stat
```

We get for each individual its FROH, and basic statistics on the population for this coeficient. 

## FHOM

FHOM is a measure of the deviation from Hardy Weinberg proportions.

```{r fhom}
het_path <- "../inst/plink_output/other_plink_outputs/het_filter.het"

FHOM_stat <- F_hom(het_path)
FHOM_stat
```

## Genomic distribution of ROH (ROH islands)

ROHi refer to regions of the genome where the proportion of individuals in a population differs from what would be expected based on a binomial distribution. We characterize these regions using the list of ROH previously identified by PLINK and the [`rohproc` R Package](https://github.com/CeballosGene/rohproc).

```{r rohi_detect}
hom <- read.table("../inst/plink_output/homozyg_output/homozyg_filter.hom", header = TRUE)
populations <- c("ADP ", "AFS")


roh_islands <- lapply(populations, function(loc) {
  assign(paste0("roh_islands_", loc), data.frame(), envir = .GlobalEnv)
})

for (pop in populations) {
  POP <- hom[hom$FID == pop, ]
  roh_islands <- data.frame()
  for (chr in 1:22) {
    roh_islands_chr <- get_RHOi(POP, chr, pop)
    roh_islands <- rbind.data.frame(roh_islands, roh_islands_chr)
  }

  # storing the results in separate variables based on the population
  if (pop == "ADP") {
    roh_islands_ADP <- roh_islands
  } else if (pop == "AFS") {
    roh_islands_AFS <- roh_islands
  }
}

head(get(paste0("roh_islands_", pop)))

```

Now we can save results as separate csv files for each group:

```{r save_results}
# save all 
for (pop in populations) {
  filename <- paste0("roh_islands_", pop, ".csv")
  write.csv(get(paste0("roh_islands_", pop)), file = filename, row.names = FALSE)
}
```

We saved the ROHi results in a directory called "rohi". Now we would like an overall summary by group:

```{r summ_by_pop}
summary <- rohi_summ_pop("rohi") # point out where the ROHi results for each group are stored
summary

```

In this case, no ROHi where identified in the ADP group.

```{r save_summary}
# save
write.table(summary,"rohi/summary_rohi.csv",quote = F, col.names = T,row.names = F, sep = ",")

```

## Functional Annotation

We performed functional annotation to identify protein-coding genes in the ROHi in our sample:

```{r prot_char}
# load data
for (pop in populations) {
  filename <- paste0("rohi/roh_islands_", pop, ".csv")
  if (file.exists(filename)) {
    data_list[[pop]] <- read.csv(filename)
    protein_tables <- lapply(data_list, rohproc::get_Prot)
    
    indices <- which(sapply(protein_tables, is.data.frame))
    for (i in indices) {
      cat(i, ":\n")
      head(protein_tables[[i]])
    }
  }
}


```

```{r save_prot_results}
# save all
sapply(which(sapply(protein_tables, is.data.frame)), function(i) {
  write.xlsx(protein_tables[[i]], file = paste0("protein_table_", i, ".xlsx"), sheetName = "Sheet1", col.names = T, row.names = F, append = F)
})
```

# Generating plots

## PCA

A principal component analysis is an excellent starting point to better understand the genetic structure of your sample:

```{r}
# read in the data
bed_file <- "../inst/data/sheep_data_QC.bed"
fam_file <- "/path/to/pop.txt" 

PLINK_pca(bed_file,fam_file)

```

## Scatter plot for length of ROH vs number of ROH

```{r}
# list of file paths and group names
file_paths <- list(
  "/path/to/homozygIndiv_pop_AFS.hom.indiv",
  "/path/to/homozygIndiv_pop_ADP.hom.indiv"
)

groups <- c(
  "AFS",
  "ADP"
)

scatter_plot(file_paths, groups)

```

## Heatmap for cryptic relatedness

```{r}
data_genome <- "/path/to/IBD_report.genome"

relatedness_hm(data_genome)
```

## Mean total length of ROH per group per category/ ROH class

```{r}
mean_length <- read.table("/path/to/mean_total_length_per_category.txt", sep = "\t", header = TRUE) # a text file where we store the mean total length of ROH in each category for each group
head(mean_length)

tn_shapes <- c(0,12,20,3,4,13,6,7,1,9)

Groups <- mean_length$ID

bar_plot <- ggplot(mean_length, aes(x = mean_length$Class, y=mean_length$Mean.cumulative.length.of.ROH..Kb., color= Groups, group = Groups, shape = Groups)) +
  geom_point(size = 2, stroke = 0.8)+
  geom_line(size = 0.6)+
  ylab("Mean total length of ROH per group (Mb)") + 
  xlab("ROH length Class (Mb)")+
  theme_classic()+
  scale_shape_manual(values = tn_shapes)+
  scale_color_manual(values = c())

bar_plot

# save
#ggsave("roh_categories_bar_plot.png", bar_plot)

```

## Violin plots

```{r}

```


## Average total length for each group according to ROH length classes



# Session Info {.unnumbered}

```{r eval=TRUE}
sessionInfo()
```
