---
title: "Runs of Homozygosity Analysis"
author:
  - name: Najla Abassi
    email: abassi.nejla96@gmail.com
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: lumen
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,
  warning = FALSE,
  fig.path = "figure/")
```

# Introduction

ROH are uninterrupted homozygous regions of the genome. They appear when two copies of an ancestral haplotype are joined in an individual. Short ROH indicate distant inbreeding, while long ROH indicate recent inbreeding.
This guide follows the Materials and Methods section from our paper () and aims to facilitate the estimate overall homozygosity of a population in R using data generated by PLINK.
To properly use this RMarkdown, you need to change the paths included here with the actual paths to your data. At the end, by knitting this document, you will be able to generate a complete report for your ROH analysis.

We start by loading all the necessary libraries:

```{r load-lib}
library("xlsx")
library("factoextra")
library("FactoMineR")
library("BEDMatrix")
library("ggplot2")
library("gridExtra")
library("tidyverse")
library("reshape2")
library("pheatmap")
library("xlsx")
library("biomaRt")
```

# Data preprocessing and Quality Control

The original data was in the .bed .bim .fam format. If your data is in .ped .map format, you should first convert it to be able to follow this guide. 
The first step we did is to perform QC using the following metrics:
  
* remove heterosomes
* SNPs with > 10% missing genotypes
* SNPs with MAF < 5%
* SNPs that are not in HW equilibrium

```{bash}
plink --bfile data --not-chr 23 24 25 26 --geno 0.1 --maf 0.05 --hwe 0.0001 --make-bed --out data_QC
```

We also need to make sure that we don't have duplicates in our data as the data comes from different sources. This step comes after merging all datasets. We remove all individuals with a PiHat = 1.

```{bash}
plink --bfile pop_merged --extract plink.prune.in --make-bed pop_pruned
plink --bfile pop_pruned --genome --min 0.05 --out ibd_report
plink --bfile pop_pruned --make-bed --out pruned_without_duplicates --remove duplucates.txt
```

# ROH identification

Now we can proceed with characterizing ROH in the processed datasets.
We start by calling the necessary functions. Please refer to the actual function documentation for further information.

```{r id_func}
# call all functions
source("./R/ROH_identification_param_functions.R")
source(".R/functions_statictical_analysis_using_plink_outputs.R")
source("./R/rohi_functions.R")
```


```{r}
hardy_path <- "/path/to/hardy_filter.hwe" # change path with your actual data path
bim_path <- "path/to/data_QC.bim"
ni <- 100 # number of individuals as example

y <- homozyg_snp(hardy_path, ni)
x <- homozyg_density(bim_path)
round(y,0)
round(x,0)
```

Now we can extract ROH with the following command:

```{bash}
plink --bfile data_QC --homozyg-window-snp 50 --homozyg-window-het 1 --homozyg-window-missing 2 --homozyg-gap 100 --homozyg-kb 500 --homozyg-density x --homozyg-snp y --out homozyg_filter
```

where `x` is the minimum number of SNPs to have less than 5% of ROH generated by chance, and `y` is the SNP density.

## Statistical analysis

Let's take a closer look of the ROH distribution in our population:

### Number of ROH and Total run length

```{r nb_length_roh}
indiv_path <- "/path/to/indiv_path.hom.indiv"

roh_summary_table <- roh_stat(indiv_path)
roh_summary_table

```

### FROH

FROH is a multipoint approach measuring individual homozygosity and indicates the proportion of the genome included in the ROH per individual. It was calculated according to the formula:

\[ FROH_j = \frac{\sum_{k} \text{length(ROH}_k\text{)}}{L} \]

```{r froh}
FROH_stat <- F_roh(indiv_path,bim_path)
FROH_stat
```

### FHOM

FHOM is a measure of the deviation from Hardy Weinberg proportions.

```{r fhom}
het_path <- "/path/to/het_filter.het"

FHOM_stat <- F_hom(het_path)
FHOM_stat
```

## Genomic distribution of ROH (ROH islands)

ROHi refer to regions of the genome where the proportion of individuals in a population differs from what would be expected based on a binomial distribution. We characterize these regions in our sample using the list of ROH previously identified by PLINK and the [`rohproc` R Package](https://github.com/CeballosGene/rohproc).

```{r rohi_detect}
hom <- read.table("/path/to/homozyg_filter.hom", header = TRUE)
populations <- c("Tunis", "Monastir", "Douz", "Rbaya", "Matmata", "Tamezret", "Zraoua", "Douiret", "Tataouine", "Sened")
roh_islands <- lapply(populations, function(loc) {
  assign(paste0("roh_islands_", loc), data.frame(), envir = .GlobalEnv)
})

for (pop in populations) {
  POP <- hom[hom$FID == pop, ]
  roh_islands <- data.frame()
  for (chr in 1:22) {
    roh_islands_chr <- get_RHOi(POP, chr, pop)
    roh_islands <- rbind.data.frame(roh_islands, roh_islands_chr)
  }

  # storing the results in separate variables based on the population
  if (pop == "Tunis") {
    roh_islands_Tunis <- roh_islands
  } else if (pop == "Monastir") {
    roh_islands_Monastir <- roh_islands
  } else if (pop == "Douz") {
    roh_islands_Douz <- roh_islands
  } else if (pop == "Rbaya") {
    roh_islands_Rbaya <- roh_islands
  } else if (pop == "Matmata") {
    roh_islands_Matmata <- roh_islands
  } else if (pop == "Tamezret") {
    roh_islands_Tamezret <- roh_islands
  } else if (pop == "Zraoua") {
    roh_islands_Zraoua <- roh_islands
  } else if (pop == "Douiret") {
    roh_islands_Douiret <- roh_islands
  } else if (pop == "Tataouine") {
    roh_islands_Tataouine <- roh_islands
  } else if (pop == "Sened") {
    roh_islands_Sened <- roh_islands
  }
}

head(get(paste0("roh_islands_", pop)))

```

Now we can save results as separate csv files for each group:

```{r save_results}
# save all 
for (pop in populations) {
  filename <- paste0("roh_islands_", pop, ".csv")
  write.csv(get(paste0("roh_islands_", pop)), file = filename, row.names = FALSE)
}
```

We saved the ROHi results in a directory called "rohi". Now we would like an overall summary by group:

```{r summ_by_pop}
summary <- rohi_summ_pop("rohi") # point out where the ROHi results for each group are stored
summary

```

```{r save_summary}
# save
write.table(summary,"summary_rohi.csv",quote = F, col.names = T,row.names = F, sep = ",")

```

## Functional Annotation

We performed functional annotation to identify protein-coding genes in the ROHi in our sample:

```{r prot_char}
# load data
for (pop in populations) {
  filename <- paste0("/path/to/rohi/rohi_", pop, ".csv")
  data_list[[pop]] <- read.csv(filename)
}

protein_tables <- lapply(data_list, get_Prot)

indices <- which(sapply(protein_tables, is.data.frame))
for (i in indices) {
  cat( i, ":\n")
  head(protein_tables[[i]])
}

```

```{r save_prot_results}
# save all
sapply(which(sapply(protein_tables, is.data.frame)), function(i) {
  write.xlsx(protein_tables[[i]], file = paste0("protein_table_", i, ".xlsx"), sheetName = "Sheet1", col.names = T, row.names = F, append = F)
})
```

# Generating plots

## PCA

A principal component analysis is an exellent starting point to better understand the genetic structure of your sample:

```{r}
# read in the data
bed_file <- "/path/to/pruned_merged_data.bed"
fam_file <- "/path/to/pop.txt" # text file with the population names (like the first column in a .fam file)

# load SNP data using BEDMatrix
snp_data <- BEDMatrix(bed_file)

# read family data
family <- read.table(fam_file)

# convert SNP data to a matrix and combine with family data
snp_matrix <- as.matrix(snp_data)
combined_data <- cbind(family, snp_matrix)

# perform PCA
pca <- PCA(snp_matrix, graph = FALSE)

# plot eigenvalues
fviz_eig(pca)

# plot individuals with their respective family labels
pca <- fviz_pca_ind(pca, habillage = combined_data$V1, repel = TRUE)

# save plot
#ggsave("pca.png", plot = pca)

```

## Scatter plot for length of ROH vs number of ROH

```{r}
# list of file paths and group names
file_paths <- list(
  "/path/to/homozygIndiv_pop_Tunis.hom.indiv",
  "/path/to/homozygIndiv_pop_Monastir.hom.indiv",
  "/path/to/homozygIndiv_pop_Douz.hom.indiv",
  "/path/to/homozygIndiv_pop_Rbaya.hom.indiv",
  "/path/to/homozygIndiv_pop_Matmata.hom.indiv",
  "/path/to/homozygIndiv_pop_Tamezret.hom.indiv",
  "/path/to/homozygIndiv_pop_Zraoua.hom.indiv",
  "/path/to/homozygIndiv_pop_Douiret.hom.indiv",
  "/path/to/homozygIndiv_pop_Tataouine.hom.indiv",
  "/path/to/homozygIndiv_pop_Sened.hom.indiv"
)

groups <- list(
  "Tunis",
  "Monastir",
  "Douz",
  "Rbaya",
  "Matmata",
  "Tamezret",
  "Zraoua",
  "Douiret",
  "Tataouine",
  "Sened"
)

# read data and add group
read_and_label_data <- function(file, group_labels) {
  data <- read.table(file)
  data <- data[data$V1 %in% names(group_labels), ]
  data$Group <- group_labels[data$V1]
  return(data)
}

# read and label data
data_list <- lapply(file_paths, read_and_label_data, groups)

# combine all data 
total_data <- do.call(rbind, data_list)

# separate data by ethnicity
data_arabes <- total_data[total_data$Group %in% c("Tunis", "Monastir", "Douz", "Rbaya"), ]
data_berbers <- total_data[total_data$Group %in% c("Matmata", "Tamezret", "Zraoua", "Sened", "Tataouine", "Douiret"), ]

data_arabes$ethnicity <- "non berbers"
data_berbers$ethnicity <- "berbers"

total_data <- rbind(data_arabes, data_berbers)

# create plot
create_plot <- function(data, title) {
  ggplot(data, aes(x = V4, y = V5 / 1000)) +
    geom_point() +
    xlim(0, 150) +
    ylim(0, 350) +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5)) +
    labs(y = "Total length of ROH (Mb)", x = "Total number of ROH") +
    ggtitle(title)
}

# create list of plots for each group
plots <- lapply(unique(total_data$Group), function(group) {
  data <- total_data[total_data$Group == group, ]
  create_plot(data, group)
})

# display plots
plot <- grid.arrange(grobs = plots, ncol = 6, nrow = 3)
plot

# save
#ggsave("plot_length_vs_number_roh.png", plot)

```

## Heatmap for cryptic relatedness

```{r}
data_genome <- read.table("/path/to/IBD_report.genome",header = T)

df1 <- data_genome[,c("IID1","IID2","PI_HAT")]

# convert long-to-wide
x <- dcast(df1, IID1 ~ IID2, value.var = "PI_HAT")

# convert to matrix with column and rownames
myM <- as.matrix(x[ , -1 ])
row.names(myM) <- x$IID1

# convert all NAs to 0
myM[ is.na(myM) ] <- 0

# plot heatmap
hm <- pheatmap(as.data.frame(myM))

# save
#ggsave("heatmap_pihat.png", hm)
```

##  Mean total length of ROH per tunisian group per category/ ROH class

```{r}
mean_length <- read.table("/path/to/mean_total_length_per_category.txt", sep = "\t", header = TRUE) # a text file where we store the mean total length of ROH in each category for each group
head(mean_length)

tn_shapes <- c(0,12,20,3,4,13,6,7,1,9)

Groups <- mean_length$ID

bar_plot <- ggplot(mean_length, aes(x = mean_length$Class, y=mean_length$Mean.cumulative.length.of.ROH..Kb., color= Groups, group = Groups, shape = Groups)) +
  geom_point(size = 2, stroke = 0.8)+
  geom_line(size = 0.6)+
  ylab("Mean total length of ROH per group (Mb)") + 
  xlab("ROH length Class (Mb)")+
  theme_classic()+
  scale_shape_manual(values = tn_shapes)+
  scale_color_manual(values = c( "Sened" ="#FF69B4", "Tataouine"= "blueviolet","Douiret" = "cyan","Matmata"="#FFD700","Tamezret"="blue","Zraoua"="black","Douz"="darkorange", "Rbaya"= "green","Tunis"="#8FBC8F", "Monastir"= "red"))

bar_plot

# save
#ggsave("roh_categories_bar_plot.png", bar_plot)

```

## Violin plots

```{r}

```


# Session Info {-}
```{r eval=TRUE}
sessionInfo()
```


