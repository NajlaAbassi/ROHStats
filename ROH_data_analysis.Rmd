---
title: "Runs of Homozygosity Analysis on a sheep dataset"
author: "Najla Abassi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  warning = FALSE)
```

## TODO: for now keep the data so that i can test the functions, but at the end just remove and keep the pipeline (eval=F for final report)

# Data preprocessing and Quality Control

The original data was in the .ped .map format. The first step we performed is to convert these file into binaries .bed .bim .fam files using the following command `plink --file sheep__46819variants__58individuals --make-bed --out sheep_data`

After that we performed QC using the previously discussed metrics `plink --bfile sheep_data --not-chr 23 24 25 26 --geno 0.1 --maf 0.05 --hwe 0.0001 --make-bed --out sheep_data_QC`

# ROH identification
Now we can proceed with characterizing ROH in the processed dataset. 

```{r id_func, echo=FALSE}
# the usage of these functions is described on the GitHub repo
homozyg_snp <- function(hardy_path,ni) {
  dataset_hardy <- read.table(hardy_path, sep= "", header = TRUE)
  Hm <- mean(dataset_hardy$O.HET., na.rm = TRUE) #Hm is the average observed heterozygosity
  ns <- nrow(dataset_hardy) #ns is the number of SNPs per individual
  ni <- as.numeric(ni)
  l <- log(0.05 / (ns- ni)) / log(1- Hm)
  return(l)
}

homozyg_density <- function(bim_path) {
  bim_file <- read.table(bim_path, sep = "\t", header = FALSE)
  snp_nb <- nrow(bim_file)
  covered_genome_size =0
  for (i in 1:22) {
    dataset_chr_i<-bim_file[ bim_file$V1 == i, ]
    size_chr_i <- max(dataset_chr_i$V4, na.rm = FALSE) - min(dataset_chr_i$V4, na.rm = FALSE)
    covered_genome_size <- covered_genome_size + size_chr_i
  }
  couverage <- covered_genome_size
  density <- snp_nb/couverage *1000
  snp_density <- 1 / density
  return(snp_density)
}
  
```

## upload data

```{r upload}
hardy_path <- "hardy_filter.hwe"
ni<- 58
bim_path <- "sheep_data_QC.bim"

y <- homozyg_snp(hardy_path, ni)
x <- homozyg_density(bim_path)
round(y,0)
round(x,0)
```

Now we can identify ROH with the following command `plink --bfile sheep_data_QC --homozyg-window-snp 50 --homozyg-window-het 1 --homozyg-window-missing 2 --homozyg-gap 100 --homozyg-kb 500 --homozyg-density 55 --homozyg-snp 29 --out homozyg_filter`

## Statistical analysis

```{r stat_func, echo=F}
roh_stat <- function(indiv_path) {
  dataset <- read.table(indiv_path, sep = "", header = T)
  ####### total length of ROH per individual##########
  #Maximum
  maximum <- round(max(dataset$KB, na.rm = TRUE)/1000,2)
  #Minimum
  minimum <- round(min(dataset$KB, na.rm = TRUE)/1000,2)
  #Mean
  mean_value <- round(mean(dataset$KB, na.rm = TRUE)/1000,2)
  #Standard Deviation
  sd_value <- round(sd(dataset$KB, na.rm = TRUE)/1000,2)
  # Summary table
  sum_table_1 <- as.data.frame(cbind(maximum,minimum,mean_value,sd_value))
  rownames(sum_table_1)[1] <- "total length"
  write.table(sum_table_1,"total length statistics.txt", sep = "\t",col.names = T,row.names = F,quote = F)
  summary_table_1 <- read.table("total length statistics.txt",header = T)
  ######## number of ROH per individual##########
  #Maximum
  maximum <- round(max(dataset$NSEG, na.rm = TRUE),2)
  #Minimum
  minimum <- round(min(dataset$NSEG, na.rm = TRUE),2)
  #Mean
  mean_value <- round(mean(dataset$NSEG, na.rm = TRUE),2)
  #Standard Deviation
  sd_value <- round(sd(dataset$NSEG, na.rm = TRUE),2)
  # Summary table
  sum_table_2 <- as.data.frame(cbind(maximum,minimum,mean_value,sd_value))
  rownames(sum_table_2)[1] <- "total number"
  write.table(sum_table_2,"mean total length statistics.txt", sep = "\t",col.names = T,row.names = F,quote = F)
  summary_table_2 <- read.table("mean total length statistics.txt",header = T)
  common_col_names <- intersect(names(summary_table_1), names(summary_table_2))
  # Summary table
  summary_table <- merge(summary_table_1, summary_table_2, by = common_col_names, all = T)
  rownames(summary_table)[1] <- "total length"
  rownames(summary_table)[2] <- "total number"
  return(summary_table)
}

F_roh <- function (data_path,bim_path) {
  setwd(getwd())
  data <- read.table(data_path, sep = "", header = T)
  id <- as.data.frame(data$IID)
  # If bim_path is a file path, read the bim file and compute genome coverage
  if (is.character(bim_path) && file.exists(bim_path)) {
    bim_file <- read.table(bim_path, sep = "\t", header = FALSE)
    snp_nb <- nrow(bim_file)
    ## Compute genome coverage
    covered_genome_size = 0
    for (i in 1:22) {
      dataset_chr_i <- bim_file[bim_file$V1 == i, ]
      size_chr_i <- max(dataset_chr_i$V4, na.rm = FALSE) - min(dataset_chr_i$V4, na.rm = FALSE)
      covered_genome_size <- covered_genome_size + size_chr_i
    }
    coverage <- round(covered_genome_size / 1000000)
  } else {
    # Otherwise, bim_path is assumed to be the numeric value `coverage`
    coverage <- as.numeric(bim_path)
  }
  # Calculate FROH
  Froh <- data.frame(matrix(NA, nrow = nrow(data), ncol = 1))
  for (i in 1:nrow(data)) {
    Froh[i,1] <- (data$KB[i]/1000) /coverage
  }
  FROH <- cbind(id,Froh)
  colnames(FROH)[1] <- "IID"
  colnames(FROH)[2] <- "Froh"
  FROH$FID <- data$FID
  FROH <- FROH[,c(3,1,2)]
  write.table(FROH,"Froh.txt", sep = "\t",col.names = T,row.names = F,quote = F)
  FROH_values <- read.table("Froh.txt", header = T)
  # Statistics for FROH
  #Mean
  mean_value <- round(mean(FROH$Froh, na.rm = TRUE),2)
  #Standard Deviation
  sd_value <- round(sd(FROH$Froh, na.rm = TRUE),2)
  #Max
  maximum <- max(FROH$Froh)
  #Min
  minimum <- min(FROH$Froh)
  # Summary table
  sum_table <- as.data.frame(cbind(maximum,minimum,mean_value,sd_value))
  write.table(sum_table,"Froh statistics.txt", sep = "\t",col.names = T,row.names = F,quote = F)
  summary_table <- read.table("Froh statistics.txt",header = T)
  return(list(FROH_values = FROH_values, summary_table = summary_table))
}

F_hom <- function(het_path) {
  dataset<- read.table(het_path, header = T)
  FHOM <- data.frame(dataset$F)
  FHOM$FID <- dataset$FID
  FHOM$IID <- dataset$IID
  FHOM <- FHOM[,c(2,3,1)]
  colnames(FHOM)[3] <- "Fhom"
  write.table(FHOM, 'Fhom.txt', sep = "\t",row.names = FALSE, col.names = T, quote = FALSE)
  FHOM_values <- read.table("Fhom.txt", header = T)
  #Statistics for FHOM
  #Mean
  mean_value <- round(mean(FHOM$Fhom, na.rm = TRUE),2)
  #Standard Deviation
  sd_value <- round(sd(FHOM$Fhom, na.rm = TRUE),2)
  #Max
  maximum <- max(FHOM$Fhom)
  # Min
  minimum <- min(FHOM$Fhom)
  # Summary table
  sum_table <- as.data.frame(cbind(maximum,minimum,mean_value,sd_value))
  write.table(sum_table,"Fhom statistics.txt", sep = "\t",col.names = T,row.names = F,quote = F)
  summary_table <- read.table("Fhom statistics.txt",header = T)
  return(list(FHOM_values = FHOM_values, summary_table = summary_table))
}

```

### Number of ROH and Total run length

```{r nb_length_roh}
indiv_path <- "homozyg_filter.hom.indiv"
summary_tbl <- roh_stat(indiv_path)
summary_tbl

```

### FROH

```{r froh}
data_path <-indiv_path
froh_stat <- F_roh(data_path,bim_path)
froh_stat
```

### FHOM

```{r fhom}
het_path <- "het_filter.het"
fhom_stat <- F_hom(het_path)
fhom_stat

```

## Genomic distribution of ROH (ROH islands)

```{r rohi_func, echo=FALSE}
# these are rohproc R pacakge functions (see original package on GitHub: https://github.com/CeballosGene/rohproc)

# FUNCTIONS ROHi
roh_island<-function(pop,chr,p1,p2){
  names(pop)<-tolower(names(pop))
  a<-pop[pop$chr==chr,]
  island<-subset(a,pos1<=p1 & pos2>=p2)
  n<-length(unique(island$iid))/length(unique(pop$iid))
  return(n)
}
poisson.roh_island<-function(pop,chr,p1,p2){
  names(pop)<-tolower(names(pop))
  a<-pop[pop$chr==chr,]
  island<-subset(a,pos1<=p1 & pos2>=p2)
  n<-length(unique(island$iid))
  return(n)
}

# Islands of ROH
get_RHOi<-function(POP,ChroNumber,population){
  SizeWindow=10000
  if(ChroNumber==1){lenChro=250000000}
  if(ChroNumber==2){lenChro=250000000}
  if(ChroNumber==3){lenChro=200000000}
  if(ChroNumber==4){lenChro=191000000}
  if(ChroNumber==5){lenChro=182000000}
  if(ChroNumber==6){lenChro=171000000}
  if(ChroNumber==7){lenChro=160000000}
  if(ChroNumber==8){lenChro=146000000}
  if(ChroNumber==9){lenChro=139000000}
  if(ChroNumber==10){lenChro=133900000}
  if(ChroNumber==11){lenChro=136000000}
  if(ChroNumber==12){lenChro=134000000}
  if(ChroNumber==13){lenChro=115000000}
  if(ChroNumber==14){lenChro=108000000}
  if(ChroNumber==15){lenChro=102000000}
  if(ChroNumber==16){lenChro=91000000}
  if(ChroNumber==17){lenChro=84000000}
  if(ChroNumber==18){lenChro=81000000}
  if(ChroNumber==19){lenChro=59000000}
  if(ChroNumber==20){lenChro=64000000}
  if(ChroNumber==21){lenChro=49000000}
  if(ChroNumber==22){lenChro=52000000}
  data.n = apply(data.frame(seq(0,lenChro-SizeWindow,SizeWindow), seq(SizeWindow,lenChro,SizeWindow)), MARGIN=1,
                 function(x,y,z,a) poisson.roh_island(POP, ChroNumber, x[1], x[2]))
  data.p = apply(data.frame(seq(0,lenChro-SizeWindow,SizeWindow), seq(SizeWindow,lenChro,SizeWindow)), MARGIN=1,
                 function(x,y,z,a) roh_island(POP, ChroNumber, x[1], x[2]))
  av<-mean(data.n)
  pval<-ppois(data.n,lambda=av,lower=FALSE)
  x<-seq(1:round(lenChro/SizeWindow))
  pos<-(x*SizeWindow)
  prop<-data.p*100
  data<-data.frame(cbind(x,data.n,prop,pos,pval))
  data.p<-subset(data,data$pval<=0.05/(lenChro/SizeWindow))
  data.re<-data.p |> dplyr::group_by(new=cumsum(c(1,diff(x)!=1))) |>
    dplyr::summarise(pos1=min(pos),pos2=max(pos),n.ind=mean(data.n),per.ind=mean(prop))
  Chr<-rep(ChroNumber,length(data.re$pos1))
  ROHi<-data.frame(cbind(Chr,data.re))
  ROHi<-dplyr::mutate(ROHi,len=(pos2-pos1)/1000000)
  ROHi<-dplyr::mutate(ROHi,pop=rep(population,length(ROHi$Chr)))
  ROHi<-dplyr::select(ROHi,Chr,pos1,pos2,len,n.ind,per.ind,pop)
  colnames(ROHi)<-c("Chr","Start","End","Length","N_Individuals","P_Individuals","Population")
  return(ROHi)
}
# Summarize by population
rohi_summ_pop<-function(mypath){
  files_list <- list.files(path=mypath, full.names=TRUE)
  dat <- data.frame()
  for (i in 1:length(files_list)) {
    dat <- rbind(dat, read.csv((files_list[i]),header=TRUE))
  }
  dat<-dat|>
    dplyr::group_by(Population)|>
    dplyr::summarise(Number=length(Chr),
                     mean_length=mean(Length),
                     sd_length=sd(Length),
                     median_Length=median(Length),
                     iqr_Length=IQR(Length),
                     max_Length=max(Length),
                     mean_N_Individuals=mean(N_Individuals),
                     sd_N_Individuals=sd(N_Individuals),
                     median_N_Individuals=median(N_Individuals),
                     iqr_N_Individuals=IQR(N_Individuals),
                     max_N_Individuals=max(N_Individuals),
                     mean_P_Individuals=mean(P_Individuals),
                     sd_P_Individuals=sd(P_Individuals),
                     median_P_Individuals=median(P_Individuals),
                     iqr_P_Individuals=IQR(P_Individuals),
                     max_P_Individuals=max(P_Individuals))
  out<-as.data.frame(dat)
  return(out)
}
```

```{r rohi_detect}
hom <- read.table("homozyg_filter.hom", header = TRUE)
populations <- c("ADP", "AFS")
roh_islands_ADP <- data.frame()
roh_islands_AFS <- data.frame()

for (pop in populations) {
  POP <- hom[hom$FID == pop, ]
  roh_islands <- data.frame()
  for (chr in 1:22) {
    roh_islands_chr <- get_RHOi(POP, chr, pop)
    roh_islands <- rbind.data.frame(roh_islands, roh_islands_chr)
  }

  # Storing the results in separate variables based on the population
  if (pop == "ADP") {
    roh_islands_ADP <- roh_islands
  } else if (pop == "AFS") {
    roh_islands_AFS <- roh_islands
  }
}


head(roh_islands_ADP)
head(roh_islands_AFS)

```
Now we can save results as csv files

```{r save_results ,eval=FALSE}
write.table(roh_islands_ADP,"rohi_ADP.csv",quote = F, col.names = T,row.names = F, sep = ",")

write.table(roh_islands_AFS,"rohi_AFS.csv",quote = F, col.names = T,row.names = F, sep = ",")

```


We saved the ROHi results in a directory called "rohi"

```{r summ_by_pop}
summary <- rohi_summ_pop("rohi")
summary

```

```{r save_summary, eval=FALSE}
write.table(summary,"summary_rohi_sheep.csv",quote = F, col.names = T,row.names = F, sep = ",")

```


## Functional Annotation

```{r prot_func, echo=F}
# these are rohproc R pacakge functions (see original package on GitHub: https://github.com/CeballosGene/rohproc)
get_Prot<-function(DATA){
  mart <- biomaRt::useMart("ENSEMBL_MART_ENSEMBL",dataset="hsapiens_gene_ensembl", host="https://www.ensembl.org")
  attributes = biomaRt::listAttributes(mart)
  attributes <- c("ensembl_gene_id","chromosome_name","start_position","end_position",
                  "gene_biotype","external_gene_name","description")
  filters <- c("chromosome_name","start","end")
  ann<-list()
  gen<-list()
  for (i in seq(1,length(DATA$Chr),1)){
    ann[[i]]<-list(chromosome=DATA[i,1],start=DATA[i,2],end=DATA[i,3])
    gen[[i]]<-biomaRt::getBM(attributes=attributes, filters=filters, values=ann[[i]], mart=mart)
    gen[[i]]<-gen[[i]][gen[[i]]$gene_biotype=="protein_coding",]
  }
  genes<- plyr::ldply(gen, data.frame)
  return(genes)
}
```

```{r prot_char}
library(biomaRt)
DATA1 <- read.csv("rohi/rohi_ADP.csv")
DATA2 <- read.csv("rohi/rohi_AFS.csv")
protein_table_ADP <- get_Prot(DATA1)
protein_table_AFS <- get_Prot(DATA2)

head(protein_table_ADP)
head(protein_table_AFS)

```

```{r save_prot_results, eval=FALSE}
library("xlsx")
write.xlsx(protein_table_ADP,"protein_table_ADP.xls", sheetName = "Sheet1", col.names = T, row.names = F, append = F)

write.xlsx(protein_table_AFS,"protein_table_AFS.xls", sheetName = "Sheet1", col.names = T, row.names = F, append = F)

```
# NB: Plots, PCA, Cryptic relatedness will be added soon...

# Session Info {-}
```{r}
sessionInfo()
```


